<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2020/01/09/mysql%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<p>title: Mysql事务特性及隔离级别<br>date: 2019-09-09<br>tags: mysql<br>categories: mysql</p><a id="more"></a>
<h3 id="1-1-2、事务的特性"><a href="#1-1-2、事务的特性" class="headerlink" title="1.1.2、事务的特性"></a>1.1.2、事务的特性</h3><ol>
<li><p>原子性</p>
<blockquote>
<p>事务中的全部操作在数据库中是不可分割的，要么全部完成，要么全都不完成</p>
</blockquote>
</li>
<li><p>一致性</p>
<blockquote>
<p>几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致</p>
</blockquote>
</li>
<li><p>隔离性</p>
<blockquote>
<p>事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的</p>
</blockquote>
</li>
<li><p>持久性</p>
<blockquote>
<p>一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作</p>
</blockquote>
</li>
</ol>
<p><img src="https://pic2.zhimg.com/80/v2-59ea2f0769e4e9ffbcdce938d306fae9_hd.png" alt="img"> </p>
<h3 id="1-1-3、事务隔离级别"><a href="#1-1-3、事务隔离级别" class="headerlink" title="1.1.3、事务隔离级别"></a>1.1.3、事务隔离级别</h3><ol>
<li><p><strong>未提交读：脏读（READ UNCOMMITTED）</strong></p>
<ol>
<li>事务2查询到的数据是事务1中修改但未提交的数据，但因为事务1回滚了数据</li>
<li>所以事务2查询的数据是不正确的，因此出现了脏读的问题</li>
</ol>
</li>
</ol>
<h3 id="READ-UNCOMMITTED（读未提交）"><a href="#READ-UNCOMMITTED（读未提交）" class="headerlink" title="READ UNCOMMITTED（读未提交）"></a>READ UNCOMMITTED（读未提交）</h3><p> 该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为<strong>脏读</strong>。 </p>
<p> 两个命令行客户端分别为A，B；不断改变A的隔离级别，在B端修改数据。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将A的隔离级别设置为read uncommitted(未提交读)</span><br><span class="line">A：SET @@session.transaction_isolation = &apos;READ-UNCOMMITTED&apos;;</span><br><span class="line">创建一张test</span><br><span class="line">create database test;</span><br><span class="line"></span><br><span class="line">use test;</span><br><span class="line"></span><br><span class="line">create table test(id int primary key);</span><br><span class="line"></span><br><span class="line">insert into test(id) values(1);</span><br><span class="line"></span><br><span class="line">A：启动事务，此时数据为初始状态</span><br><span class="line">start transaction;</span><br><span class="line"></span><br><span class="line">B：启动事务，更新数据，但不提交</span><br><span class="line">start transaction;</span><br><span class="line">update test set id = 2 where id = 1;</span><br><span class="line"></span><br><span class="line">A：再次读取数据，发现数据已经被修改了，这就是所谓的“脏读</span><br><span class="line">select * from test;</span><br><span class="line"></span><br><span class="line">B:回滚事务</span><br><span class="line">rollback;</span><br><span class="line"></span><br><span class="line">A:再次读数据，发现数据变回初始状态</span><br><span class="line">select * from test;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>提交读：不可重复读（READ COMMITTED）</strong></p>
<p>注：一个事务从开始到提交之前对数据所做的改变对其他事务是不可见的，这样就解决在READ-UNCOMMITTED级别下的脏读问题。</p>
<ol>
<li>事务2执行update语句但未提交前，事务1的前两个select操作返回结果是相同的</li>
<li>但事务2执行commit操作后，事务1的第三个select操作就读取到事务2对数据的改变</li>
<li>导致与前两次select操作返回不同的数据，因此出现了不可重复读的问题</li>
</ol>
</li>
</ol>
<h3 id="READ-COMMITTED（提交读）"><a href="#READ-COMMITTED（提交读）" class="headerlink" title="READ COMMITTED（提交读）"></a>READ COMMITTED（提交读）</h3><p> 一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为不可重复读问题，Oracle 和 SQL Server 的默认隔离级别。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A:将客户端A的事务隔离级别设置为read committed(已提交读)</span><br><span class="line"></span><br><span class="line">SET @@session.transaction_isolation = &apos;READ-COMMITTED&apos;;</span><br><span class="line">创建test表</span><br><span class="line">create database test;</span><br><span class="line">use test;</span><br><span class="line">create table test(id int primary key);</span><br><span class="line">insert into test(id) values(1);</span><br><span class="line"></span><br><span class="line">A：启动事务，此时数据为初始状态</span><br><span class="line">start transaction;</span><br><span class="line"></span><br><span class="line">B：启动事务，更新数据，但不提交</span><br><span class="line">start transaction;</span><br><span class="line">update test set id = 2 where id = 1;</span><br><span class="line"></span><br><span class="line">A：再次读数据，发现数据未被修改</span><br><span class="line">select * from test;</span><br><span class="line"></span><br><span class="line">B：提交事务</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">A：再次读取数据，发现数据已发生变化，说明B提交的修改被事务中的A读到了，这就是所谓的“不可重复读”</span><br><span class="line">select * from test;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>可重复读：幻读（REPEATABLE READ）：这是MySQL的默认事务隔离级别</strong><ol>
<li>事务每开启一个实例，都会分配一个版本号给它，如果读取的数据行正在被其他事务执行DELETE或UPDATE操作（既该行上有排他锁）</li>
<li>这时该事务的读取操作不会等待行上的锁释放，而是根据版本号去读取行的快照数据（记录在undo log中）</li>
<li>这样，事务中的查询操作返回的都是同一版本下的数据，解决了不可重复读问题。</li>
<li>虽然该隔离级别下解决了不可重复读问题，但理论上会导致另一个问题：幻读（Phantom Read）。</li>
<li>一个事务在执行过程中，另一个事务对已有数据行的更改，MVCC机制可保障该事务读取到的原有数据行的内容相同</li>
<li>但并不能阻止另一个事务插入新的数据行，这就会导致该事务中凭空多出数据行，像出现了幻读一样，这便是幻读问题</li>
</ol>
</li>
</ol>
<h3 id="REPEATABLE-READ（可重复读）"><a href="#REPEATABLE-READ（可重复读）" class="headerlink" title="REPEATABLE READ（可重复读）"></a>REPEATABLE READ（可重复读）</h3><p> 该隔离级别是 MySQL 默认的隔离级别，在同一个事务里，<code>select</code> 的结果是事务开始时时间点的状态，因此，同样的 <code>select</code> 操作读到的结果会是一致的，但是，会有<strong>幻读</strong>现象 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将A的隔离级别设置为repeatable read(可重复读)</span><br><span class="line">SET @@session.transaction_isolation = &apos;REPEATABLE-READ&apos;;</span><br><span class="line">create database test;</span><br><span class="line">use test;</span><br><span class="line">create table test(id int primary key,name varchar(20));</span><br><span class="line"></span><br><span class="line">A：登录 mysql 终端 A，开启一个事务。</span><br><span class="line">start transaction;</span><br><span class="line">select * from test; -- 无记录</span><br><span class="line"></span><br><span class="line">B：登录 mysql 终端 B，开启一个事务。</span><br><span class="line">use test;</span><br><span class="line">start transaction;</span><br><span class="line">select * from test; -- 无记录</span><br><span class="line"></span><br><span class="line">A:切换到 mysql 终端 A，增加一条记录并提交。</span><br><span class="line">insert into test(id,name) values(1,&apos;a&apos;);</span><br><span class="line">commit;</span><br><span class="line">select * from test; --可以看到已经更改</span><br><span class="line"></span><br><span class="line">B:切换到 msyql 终端 B。</span><br><span class="line">select * from test; --此时查询还是无记录</span><br><span class="line"></span><br><span class="line">通过这一步可以证明，在该隔离级别下已经读取不到别的已提交的事务，如果想看到 mysql 终端 1 提交的事务，在 mysql 终端 2 将当前事务提交后再次查询就可以读取到 mysql 终端 1 提交的事务。</span><br><span class="line"> 可重复读隔离级别只允许读取已提交记录，而且在一个事务两次读取一个记录期间，其他事务部的更新该记录。 </span><br><span class="line"></span><br><span class="line">B：此时接着在 mysql 终端 B 插入一条数据。</span><br><span class="line">insert into test(id,name) values(1,&apos;b&apos;); -- 此时报主键冲突的错误</span><br><span class="line">这就是该隔离级别下可能产生的问题，MySQL 称之为幻读。</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>可串行读（SERIALIZABLE）</strong></p>
<ol>
<li>这是事务的最高隔离级别，通过强制事务排序，使之不可能相互冲突，就像在每个读的数据行加上共享锁来实现</li>
<li>在该隔离级别下，可以解决前面出现的脏读、不可重复读和幻读问题，但也会导致大量的超时和锁竞争现象，一般不推荐使用</li>
</ol>
</li>
</ol>
<h3 id="SERIALIZABLE（可串行读）"><a href="#SERIALIZABLE（可串行读）" class="headerlink" title="SERIALIZABLE（可串行读）"></a>SERIALIZABLE（可串行读）</h3><p> 在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A:准备两个终端，在此命名为 mysql 终端 A 和 mysql 终端 B，分别登入 mysql，准备一张测试表 test 并调整隔离级别为 SERIALIZABLE，任意一个终端执行即可。</span><br><span class="line">set session transaction isolation level serializable;</span><br><span class="line">create database test;</span><br><span class="line">use test;</span><br><span class="line">create table test(id int primary key);</span><br><span class="line">insert into test(id) values(1);</span><br><span class="line"></span><br><span class="line">A:登录 mysql 终端 A，开启一个事务，并写入一条数据。</span><br><span class="line">start transaction;</span><br><span class="line">select * from test;</span><br><span class="line"></span><br><span class="line">B:登录 mysql 终端 B，开启一个事务。</span><br><span class="line">start transaction;</span><br><span class="line">select * from test; </span><br><span class="line"> delete from test;</span><br><span class="line"></span><br><span class="line">A:立马切换到 mysql 终端 A,提交事务。</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">一旦事务提交，msyql 终端 B 会立马返回 ID 为 1 的记录，否则会一直卡住，直到超时，其中超时参数是由 innodb_lock_wait_timeout 控制</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/01/09/mysql%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>title: Mysql忘记密码<br>date: 2019-09-09<br>tags: mysql<br>categories: mysql</p><a id="more"></a>
<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 关闭正在运行的MySQL服务</span><br><span class="line">2. 打开DOS窗口，转到mysql\bin目录</span><br><span class="line">3. 输入mysqld --skip-grant-tables 回车       --skip-grant-tables 的意思是启动MySQL服务的时候跳过权限表认证</span><br><span class="line">4. 再开一个DOS窗口（因为刚才那个DOS窗口已经不能动了），转到mysql\bin目录 </span><br><span class="line">5. 输入mysql回车，如果成功，将出现MySQL提示符 &gt;</span><br><span class="line">6. 连接权限数据库： use mysql;</span><br><span class="line">6. 改密码：update user set password=password(&quot;root&quot;) where user=&quot;root&quot;; </span><br><span class="line">   mysql5.7以上版本--&gt;    UPDATE user SET authentication_string=PASSWORD(&quot;root&quot;) WHERE User=&quot;root&quot;;</span><br><span class="line">7. 刷新权限（必须步骤）：flush privileges;　</span><br><span class="line">8. 退出 quit。 </span><br><span class="line">9. 注销系统，再进入，使用用户名root和刚才设置的新密码123登录。</span><br></pre></td></tr></table></figure>

<h1 id="Centos7"><a href="#Centos7" class="headerlink" title="Centos7"></a>Centos7</h1><p>1.修改MySQL的配置文件（默认为/etc/my.cnf）,在[mysqld]下添加一行skip-grant-tables </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure>

<p>2.保存配置文件后，重启MySQL服务 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysqld restart（注：根据自己的情况重启mysql )</span><br><span class="line"></span><br><span class="line">error:Redirecting to /bin/systemctl restart  mysqld.service</span><br><span class="line">service mysqld status</span><br><span class="line"></span><br><span class="line">error:Failed to restart mysqld.drtvice.service: Unit not found.</span><br><span class="line">请重装</span><br></pre></td></tr></table></figure>

<p>3.再次进入MySQL命令行 mysql -uroot -p,输入密码时直接回车，就会进入MySQL数据库了，这个时候按照常规流程修改root密码即可。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;use mysql;    更改数据库</span><br><span class="line"></span><br><span class="line">&gt;UPDATE user SET PASSORD =password(&quot;自己重新设置的密码写此处&quot;) WHERE USER= &apos;root&apos;;  重设密码</span><br></pre></td></tr></table></figure>

<p>4.如果是 centos 7以上的；可能会失败；修改密码操作改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update mysql.user set authentication_string=password(&apos;自己重新设置的密码写此处&apos;) where user=&apos;root&apos; ;</span><br></pre></td></tr></table></figure>

<p>5.刷新MySQL的系统权限相关表，以防止更改后拒绝访问；或者重启MySQL服务器 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>6.密码修改完毕后，再按照步骤1中的流程，删掉配置文件中的那行，并且重启MySQL服务，新密码就生效了。 </p>
<h5 id="后续解密"><a href="#后续解密" class="headerlink" title="后续解密"></a>后续解密</h5><p>ERROR 1820 (HY000): Unknown error 1820</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET PASSWORD = PASSWORD(&apos;新密码&apos;);</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>vue定时器实时更新数据</title>
    <url>/2019/08/07/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>##Vue中使用计时器实时刷新页面数据</p><p>###需求说明</p><p>在前端开发中，往往会遇到页面需要实时刷新数据的情况，给用户最新的数据展示。</p><a id="more"></a>


<p>###逻辑分析</p>
<p>如果需要数据实时更新，我们自然是需要使用定时器，不断的调用接口数据，会相对的消耗内存。</p>
<p>###代码示例</p>
<p>data(){<br>return {<br>    intervalId:null<br>    }<br>},<br>methods:{<br>// 定时刷新数据函数<br>dataRefreh() {<br>  // 计时器正在进行中，退出函数<br>  if (this.intervalId != null) {<br>    return;<br>  }<br>  // 计时器为空，操作<br>  this.intervalId = setInterval(() =&gt; {<br>    console.log(“刷新” + new Date());<br>    this.initData(); //加载数据函数<br>  }, 5000);<br>},<br>// 停止定时器<br>clear() {<br>  clearInterval(this.intervalId); //清除计时器<br>  this.intervalId = null; //设置为null<br>    },<br>},<br>created(){<br>this.dataRefreh();<br>    },<br>destroyed(){<br>// 在页面销毁后，清除计时器<br>this.alear();<br>    }</p>
<p>###代码分析</p>
<p>首先选择数据刷新的时机，在created中。<br>声明计时器，与数据刷新函数。<br>在页面销毁的时机（destroyed），关闭计时器等耗时操作。</p>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Redisearch实现的全文检索功能服务</title>
    <url>/2019/08/06/%E4%BD%BF%E7%94%A8Redisearch%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%8A%9F%E8%83%BD%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>“检索”是很多产品中无法绕开的一个功能模块，当数据量小的时候可以使用模糊查询等操作凑合一下，但是当面临海量数据和高并发的时候，业界常用 elasticsearch 和 lucene 等方案，但是elasticsearch对运行时内存有着最低限额，其运行时大小推荐 2G 以上的内存空间，并且需要额外的磁盘空间做持久化存储。</p><a id="more"></a>
<pre><code>其实mongoDB 内置的正则匹配搜索文本以及自带的 text 索引和 search 关键字也是一套靠谱的解决方案，但是这一次我们带来一种更加高效经济的文本检索方案：Redisearch

下图是elasticsearch和redisearch的性能对比



Redis Modules 是 redis 4.0 引入的一种扩展机制，用户可以通过实现 redis module 提供的 C api 接口为 redis 服务添加定制化功能。 redisLab 也希望籍此来规范 redis 社区的 ecosystem 实现。

redis module 本身的版本独立于redis，并且以编译成动态加载库 .so 文件的方式 release， 不同版本的 redis 可以 load 同一版本 module.so 文件。

redis 提供了两种加载方式。可以通过 在 conf 文件中 加入 loadmodule /path/to/mymodule.so ，也可以在 redis-cli中使用命令 MODULE LOAD /path/to/panda.so 动态加载，MODULE UNLOAD 卸载。


特性

基于文档的全文索引。
高性能增量索引。
支持文档评分，文档字段(field) 权重机制。
支持布尔复杂查询。
支持自动补全。
基于 snowball 的词干分析，多语言支持。使用 friso 支持中文分词。
utf-8 字符集支持。
redis 数据持久化支持。
自定义评分机制。



其原理是在 redis 的 hashmap 基础上就可以很容易实现倒排索引的结构。redisearch 倒排索引除了实现了基础功能外，还引入了内存管理等优化功能。如果有兴趣可以阅读源码中的 src/inverted_index.c 部分



首先，安装Rediseach,记住一点你本地的redis服务版本必须在4.0以上，网上一大堆编译安装的攻略，繁琐又浪费时间，所以又到了Docker登场时间了，hub上有编译好的免费镜像供我们下载</code></pre><p>docker pull redislabs/redisearch<br>    下载后，直接在后台启动服务</p>
<p>docker run -d -p 6666:6379 redislabs/redisearch:latest</p>
<pre><code>此时已经有一个docker容器在后台启动了，redis服务映射到了宿主的6666端口，我们来连接一下</code></pre><p>redis-cli -h localhost -p 6666</p>
<pre><code>检查 modules 是否成功加载</code></pre><p>localhost:6666&gt; MODULE list</p>
<p>1) 1) “name”<br>   2) “ft”<br>   3) “ver”<br>   4) (integer) 10405<br>    如果返回数组中存在 “ft” ， 则表明 redisearch 已经成功加载。</p>
<pre><code>Redisearch 的索引概念 与elasticsearch 的 index 类似，表示某一类文档资源单元。

这里我们定义了一个 SMARTX_VM 索引，其中存储的文档 包含 了 title 和 desc 两个 类型为 TEXT 的field。</code></pre><p>FT.CREATE SMARTX_VM SCHEMA title TEXT WEIGHT 5.0 desc TEXT<br>    然后向刚刚创建的这条索引加一个文档</p>
<p>FT.ADD SMARTX_VM vm-2019082911110001 1.0 LANGUAGE “chinese” FIELDS title “人工智能” desc “我在北京昌平学习人工智能”<br>    LANGUAGE “chinese” 参数 表示 使用 中文分词器 处理文本。默认为英文</p>
<pre><code>此时我们进行文档检索</code></pre><p>FT.SEARCH SMARTX_VM “人工智能” LANGUAGE “chinese”<br>    注意检索的时候也要指定语言，这里我们用中文分词，默认的英文分词是无法检索中文的</p>
<pre><code>可以看到已经返回了我们想要的结果。


Redisearch 是一个高效，功能完备的内存存储的高性能全文检索组件， 十分适合应用在数据量适中， 内存和存储空间有限的环境。借助数据同步手段，我们可以很方便的将redisearch 结合到现有的数据存储中， 进而向产品提供 全文检索， 自动补全等服务优化功能。</code></pre>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3.7.2+Django2.0.4 商城集成最新版支付宝支付接口</title>
    <url>/2019/07/02/Python3.7.2+Django2.0.4%20%E5%95%86%E5%9F%8E%E9%9B%86%E6%88%90%E6%9C%80%E6%96%B0%E7%89%88%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>  最新版支付宝算法的改变就是RSA升级了RSA2,长度推荐2048,其他的逻辑变化不大，关于秘钥的生成在之前的一篇文章已经有所介绍</p><a id="more"></a>
<p>  在Mac系统下生成新版支付宝（2019年4月）支付接口私钥和公钥</p>
<p>  在Django中集成支付接口的前置操作就是需要安装pycryptodome</p>
<p>  pip3 install -i <a href="https://pypi.douban.com/simple" target="_blank" rel="noopener">https://pypi.douban.com/simple</a> pycryptodome</p>
<p>  然后将之前生成好的私钥和公钥（注意这里的公钥是指支付宝公钥），放入到项目目录中去</p>
<p>  </p>
<p>  <br>  文档地址：<a href="https://docs.open.alipay.com/api" target="_blank" rel="noopener">https://docs.open.alipay.com/api</a></p>
<p>  然后根据支付宝官网文档写一个支付基类 pay.py</p>
<p>from datetime import datetime<br>from Crypto.PublicKey import RSA<br>from Crypto.Signature import PKCS1_v1_5<br>from Crypto.Hash import SHA256<br>from urllib.parse import quote_plus<br>from urllib.parse import urlparse, parse_qs<br>from base64 import decodebytes, encodebytes<br>import json</p>
<p>class AliPay(object):<br>    “””<br>    支付宝支付接口(PC端支付接口)<br>    “””</p>
<pre><code>def __init__(self, appid, app_notify_url, app_private_key_path,
             alipay_public_key_path, return_url, debug=False):
    self.appid = appid
    self.app_notify_url = app_notify_url
    self.app_private_key_path = app_private_key_path
    self.app_private_key = None
    self.return_url = return_url
    with open(self.app_private_key_path) as fp:
        self.app_private_key = RSA.importKey(fp.read())
    self.alipay_public_key_path = alipay_public_key_path
    with open(self.alipay_public_key_path) as fp:
        self.alipay_public_key = RSA.importKey(fp.read())

    if debug is True:
        self.__gateway = &quot;https://openapi.alipaydev.com/gateway.do&quot;
    else:
        self.__gateway = &quot;https://openapi.alipay.com/gateway.do&quot;

def direct_pay(self, subject, out_trade_no, total_amount, return_url=None, **kwargs):
    biz_content = {
        &quot;subject&quot;: subject,
        &quot;out_trade_no&quot;: out_trade_no,
        &quot;total_amount&quot;: total_amount,
        &quot;product_code&quot;: &quot;FAST_INSTANT_TRADE_PAY&quot;,
        # &quot;qr_pay_mode&quot;:4
    }

    biz_content.update(kwargs)
    data = self.build_body(&quot;alipay.trade.page.pay&quot;, biz_content, self.return_url)
    return self.sign_data(data)

def build_body(self, method, biz_content, return_url=None):
    data = {
        &quot;app_id&quot;: self.appid,
        &quot;method&quot;: method,
        &quot;charset&quot;: &quot;utf-8&quot;,
        &quot;sign_type&quot;: &quot;RSA2&quot;,
        &quot;timestamp&quot;: datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;),
        &quot;version&quot;: &quot;1.0&quot;,
        &quot;biz_content&quot;: biz_content
    }

    if return_url is not None:
        data[&quot;notify_url&quot;] = self.app_notify_url
        data[&quot;return_url&quot;] = self.return_url

    return data

def sign_data(self, data):
    data.pop(&quot;sign&quot;, None)
    # 排序后的字符串
    unsigned_items = self.ordered_data(data)
    unsigned_string = &quot;&amp;&quot;.join(&quot;{0}={1}&quot;.format(k, v) for k, v in unsigned_items)
    sign = self.sign(unsigned_string.encode(&quot;utf-8&quot;))
    # ordered_items = self.ordered_data(data)
    quoted_string = &quot;&amp;&quot;.join(&quot;{0}={1}&quot;.format(k, quote_plus(v)) for k, v in unsigned_items)

    # 获得最终的订单信息字符串
    signed_string = quoted_string + &quot;&amp;sign=&quot; + quote_plus(sign)
    return signed_string

def ordered_data(self, data):
    complex_keys = []
    for key, value in data.items():
        if isinstance(value, dict):
            complex_keys.append(key)

    # 将字典类型的数据dump出来
    for key in complex_keys:
        data[key] = json.dumps(data[key], separators=(&apos;,&apos;, &apos;:&apos;))

    return sorted([(k, v) for k, v in data.items()])

def sign(self, unsigned_string):
    # 开始计算签名
    key = self.app_private_key
    signer = PKCS1_v1_5.new(key)
    signature = signer.sign(SHA256.new(unsigned_string))
    # base64 编码，转换为unicode表示并移除回车
    sign = encodebytes(signature).decode(&quot;utf8&quot;).replace(&quot;n&quot;, &quot;&quot;)
    return sign

def _verify(self, raw_content, signature):
    # 开始计算签名
    key = self.alipay_public_key
    signer = PKCS1_v1_5.new(key)
    digest = SHA256.new()
    digest.update(raw_content.encode(&quot;utf8&quot;))
    if signer.verify(digest, decodebytes(signature.encode(&quot;utf8&quot;))):
        return True
    return False

def verify(self, data, signature):
    if &quot;sign_type&quot; in data:
        sign_type = data.pop(&quot;sign_type&quot;)
    # 排序后的字符串
    unsigned_items = self.ordered_data(data)
    message = &quot;&amp;&quot;.join(u&quot;{}={}&quot;.format(k, v) for k, v in unsigned_items)
    return self._verify(message, signature)

最后在视图文件中定义方法就可以了</code></pre><p>#导入支付基类<br>from .pay import Alipay</p>
<p>#初始化阿里支付对象<br>def get_ali_object():<br>    # 沙箱环境地址：<a href="https://openhome.alipay.com/platform/appDaily.htm?tab=info" target="_blank" rel="noopener">https://openhome.alipay.com/platform/appDaily.htm?tab=info</a><br>    app_id = “2016092600603658”  #  APPID （沙箱应用）</p>
<pre><code># 支付完成后，支付偷偷向这里地址发送一个post请求，识别公网IP,如果是 192.168.20.13局域网IP ,支付宝找不到，def page2() 接收不到这个请求
notify_url = &quot;http://localhost:8000/md_admin/alipayreturn&quot;

# 支付完成后，跳转的地址。
return_url = &quot;http://localhost:8000/md_admin/alipayreturn&quot;

merchant_private_key_path = &quot;c:/Users/liuyue/www/md/keys/app_private_2048.txt&quot; # 应用私钥
alipay_public_key_path = &quot;c:/Users/liuyue/www/md/keys/alipay_public_2048.txt&quot;  # 支付宝公钥

alipay = AliPay(
    appid=app_id,
    app_notify_url=notify_url,
    return_url=return_url,
    app_private_key_path=merchant_private_key_path,
    alipay_public_key_path=alipay_public_key_path,  # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥
    debug=True,  # 默认False,
)
return alipay</code></pre><p>def page1(request):</p>
<pre><code>if request.method == &quot;POST&quot;:

    # 根据当前用户的配置，生成URL，并跳转。
    money = float(request.POST.get(&apos;money&apos;))

    alipay = get_ali_object()

    # 生成支付的url
    query_params = alipay.direct_pay(
        subject=&quot;test&quot;,  # 商品简单描述
        out_trade_no=&quot;myorder&quot; + str(time.time()),  # 用户购买的商品订单号（每次不一样） 20180301073422891
        total_amount=money,  # 交易金额(单位: 元 保留俩位小数)
    )

    pay_url = &quot;https://openapi.alipaydev.com/gateway.do?{0}&quot;.format(query_params)  # 支付宝网关地址（沙箱应用）

    return redirect(pay_url)
else:
    return render(request,&apos;md_admin/page1.html&apos;)</code></pre><p>def alipay_return(request):<br>    alipay = get_ali_object()<br>    params = request.GET.dict()<br>    sign = params.pop(‘sign’, None)<br>    status = alipay.verify(params, sign)<br>    print(‘==================开始==================’)<br>    print(‘GET验证’, status)<br>    print(‘==================结束==================’)<br>    return HttpResponse(‘支付成功’)</p>
<pre><code>搞定收工</code></pre>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>os模块常用命令</title>
    <url>/2019/06/07/os%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>##os常用命令</p><p>os.makedirs(‘dir1/dir2’)       #可生成多层递归目录<br>os.mkdir(‘dir3’)               #生成单级目录；相当于shell中mkdir dirname<br>os.mkdir(‘dir3/dir4’)</p><a id="more"></a>

<p>os.rmdir(‘dir3/dir4’)　　　   # 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname<br>os.removedirs(‘dir3/dir4’)　　#若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推<br>os.removedirs(‘dir1/dir2’)</p>
<p>os.listdir(‘dirname’)    　　　　 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印<br>os.remove() 　　　　　　　　 　　　 删除一个文件<br>os.rename(“oldname”,”newname”)   重命名文件/目录<br>os.stat(‘path/filename’)  　　　　获取文件/目录信息<br>os.path<br>os.path.abspath(path)   返回path规范化的绝对路径<br>os.path.split(path)     将path分割成目录和文件名二元组返回<br>os.path.dirname(path)   返回path的目录。其实就是os.path.split(path)的第一个元素<br>os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</p>
<p>os.system(“bash command”)        运行shell命令，直接显示<br>os.popen(“bash command).read()   运行shell命令，获取执行结果<br>os.getcwd()                      获取当前工作目录，即当前python脚本工作的目录路径<br>os.chdir(“dirname”)              改变当前脚本工作目录；相当于shell下cd</p>
<p>os.path.exists(path)                 如果path存在，返回True；如果path不存在，返回False<br>os.path.isabs(path)                  如果path是绝对路径，返回True<br>os.path.isfile(path)                 如果path是一个存在的文件，返回True。否则返回False<br>os.path.isdir(path)                  如果path是一个存在的目录，则返回True。否则返回False<br>os.path.join(path1[, path2[, …]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略<br>os.path.getatime(path)               返回path所指向的文件或者目录的最后访问时间<br>os.path.getmtime(path)               返回path所指向的文件或者目录的最后修改时间<br>os.path.getsize(path)                返回path的大小</p>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python3和高性能全文检索引擎Redisearch进行交互</title>
    <url>/2019/06/07/%E4%BD%BF%E7%94%A8python3%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%BC%95%E6%93%8ERedisearch%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<p> 上一篇介绍了一款高性能全文检索引擎Redisearch，它不仅性能强劲，部署也方便，这里介绍一下如何用python客户端和它进行交互。使用redisearch-python:<a href="https://github.com/RediSearch/redisearch-py" target="_blank" rel="noopener">https://github.com/RediSearch/redisearch-py</a></p><a id="more"></a>
<p>首先，安装</p>
<p>pip3 install redisearch<br>    基本操作:</p>
<p>from redisearch import Client, TextField</p>
<h1 id="Creating-a-client-with-a-given-index-name"><a href="#Creating-a-client-with-a-given-index-name" class="headerlink" title="Creating a client with a given index name"></a>Creating a client with a given index name</h1><p>client = Client(‘myIndex’,host=’localhost’,port=’6666’)</p>
<h1 id="Creating-the-index-definition-and-schema"><a href="#Creating-the-index-definition-and-schema" class="headerlink" title="Creating the index definition and schema"></a>Creating the index definition and schema</h1><p>client.create_index((TextField(‘title’), TextField(‘body’)))</p>
<h1 id="Indexing-a-document"><a href="#Indexing-a-document" class="headerlink" title="Indexing a document"></a>Indexing a document</h1><p>client.add_document(‘doc2’, title = ‘你好’, body = ‘我在北京学习人工智能’,language=’chinese’)</p>
<h1 id="Simple-search"><a href="#Simple-search" class="headerlink" title="Simple search"></a>Simple search</h1><p>res = client.search(“人工智能”)</p>
<p>print(res.docs[0].title)<br>    可以看到，基本上和命令行中的操作方式没有太大区别，只是在search时不需要指定语言了，程序可以自主判断。</p>
<pre><code>其实它的官方文档很简单，只是介绍了基本用法，但是你如果阅读了它的源码，发现一些常用操作它也进行了封装，比如</code></pre><p>#删除索引<br>client.drop_index()</p>
<p>#获取当前索引的基本信息<br>client.info()</p>
<p>#删除文档<br>client.delete_document(‘doc2’)</p>
<pre><code>还是非常简单的，基本上，我们可以抛弃ES了，因为研发人员都是喜新厌旧的。</code></pre>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql索引类型及创建索引</title>
    <url>/2018/08/08/mysql%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><h6 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h6><p>​        MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构。我们可以简单理解为：快速查找排好序的一种数据结构。Mysql索引主要有两种结构：B+Tree索引和Hash索引。我们平常所说的索引，如果没有特别指明，一般都是指B树结构组织的索引(B+Tree索引)。索引如图所示：</p><a id="more"></a>
<p><img src="mysql%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95/B%E6%A0%91%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="B树"></p>
<p>​        索引类似一本书的目录，可以提高数据检索的效率，降低数据库的IO成本。MySQL在300万条记录左右性能开始逐渐下降，虽然官方文档说500~800w记录，所以大数据量建立索引是非常有必要的。MySQL提供了Explain，用于显示SQL执行的详细信息，可以进行索引的优化。 </p>
<p>MySQL目前主要有以下几种索引类型：</p>
<p>1.<strong>普通索引</strong></p>
<p>2.<strong>唯一索引</strong></p>
<p>3.<strong>主键索引</strong></p>
<p>4.<strong>联合索引</strong></p>
<p>5.<strong>联合唯一索引</strong></p>
<p>6.<strong>全文索引</strong></p>
<h4 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name[col_name]</span><br><span class="line">[unique|fulltext] [index|key] [index_name] (col_name[length])[asc|desc]</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">CREATE TABLE [unique|fulltext] [index|key] [index_name] on table_name[col_name[length]] [asc|desc]</span><br></pre></td></tr></table></figure>

<h6 id="1-unique-fulltext为可选参数，分别表示唯一索引、全文索引"><a href="#1-unique-fulltext为可选参数，分别表示唯一索引、全文索引" class="headerlink" title="1.unique|fulltext为可选参数，分别表示唯一索引、全文索引"></a>1.unique|fulltext为可选参数，分别表示唯一索引、全文索引</h6><h6 id="2-index和key为同义词，两者作用相同，用来指定创建索引"><a href="#2-index和key为同义词，两者作用相同，用来指定创建索引" class="headerlink" title="2.index和key为同义词，两者作用相同，用来指定创建索引"></a>2.index和key为同义词，两者作用相同，用来指定创建索引</h6><h6 id="3-col-name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择"><a href="#3-col-name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择" class="headerlink" title="3.col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择"></a>3.col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择</h6><h6 id="4-index-name指定索引的名称，为可选参数，如果不指定，默认col-name为索引值"><a href="#4-index-name指定索引的名称，为可选参数，如果不指定，默认col-name为索引值" class="headerlink" title="4.index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值"></a>4.index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值</h6><h6 id="5-length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度"><a href="#5-length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度" class="headerlink" title="5.length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度"></a>5.length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度</h6><h6 id="6-asc或desc指定升序或降序的索引值存储"><a href="#6-asc或desc指定升序或降序的索引值存储" class="headerlink" title="6.asc或desc指定升序或降序的索引值存储"></a>6.asc或desc指定升序或降序的索引值存储</h6><blockquote>
<h4 id="注意：create-语法不能创建主键索引-只有alter语法可以！"><a href="#注意：create-语法不能创建主键索引-只有alter语法可以！" class="headerlink" title="注意：create 语法不能创建主键索引,只有alter语法可以！"></a>注意：create 语法不能创建主键索引,只有alter语法可以！</h4></blockquote>
<h4 id="三、索引类型"><a href="#三、索引类型" class="headerlink" title="三、索引类型"></a>三、索引类型</h4><h6 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1.普通索引"></a>1.普通索引</h6><p>是最基本的索引，它没有任何限制。它有以下几种创建方式：<br>（1）直接创建索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE INDEX index_name ON table(column(length))</span><br></pre></td></tr></table></figure>

<p>（2）修改表结构的方式添加索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX index_name ON (column(length))</span><br></pre></td></tr></table></figure>

<p>（3）创建表的时候同时创建索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    `content` text CHARACTER NULL ,</span><br><span class="line">    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    INDEX index_name (title(length))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>（4）删除索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name ON table</span><br></pre></td></tr></table></figure>

<h6 id="2-唯一索引"><a href="#2-唯一索引" class="headerlink" title="2.唯一索引"></a>2.唯一索引</h6><p>与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：<br>（1）创建唯一索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON table(column(length))</span><br><span class="line"></span><br><span class="line"># 还有一种情况就是,我们需要为以前的表 创建这个索引,有可能以前的数据中存在重复的记录 那怎么办呢? </span><br><span class="line">alter ignore table tablename add unique index(aa); </span><br><span class="line">#它会删除重复的记录（会保留一条），然后建立唯一索引，高效而且人性化。</span><br></pre></td></tr></table></figure>

<p>（2）修改表结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))</span><br></pre></td></tr></table></figure>

<p>（3）创建表的时候直接指定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    `content` text CHARACTER NULL ,</span><br><span class="line">    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">    UNIQUE indexName (title(length))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="3-主键索引"><a href="#3-主键索引" class="headerlink" title="3.主键索引"></a>3.主键索引</h6><p>是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) NOT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>设置字段为主键索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` );</span><br></pre></td></tr></table></figure>

<h6 id="4-联合索引（复合索引）"><a href="#4-联合索引（复合索引）" class="headerlink" title="4.联合索引（复合索引）"></a>4.联合索引（复合索引）</h6><blockquote>
<p>​        指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合</p>
<p>​        两个或更多个列上的索引被称作复合索引。</p>
<p>​        利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知 道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名字不知道姓，电话簿将没有任何用处。</p>
<p>​        所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `table` ADD INDEX name_city_age (name,city,age);</span><br></pre></td></tr></table></figure>

<h6 id="5-联合唯一索引（复合唯一索引）"><a href="#5-联合唯一索引（复合唯一索引）" class="headerlink" title="5.联合唯一索引（复合唯一索引）"></a>5.联合唯一索引（复合唯一索引）</h6><blockquote>
<p> 多列惟一性索引，保证多个值的组合不重复。 </p>
</blockquote>
<p>(1) 创建联合唯一索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line"># create unique index 索引名字 on 表名(字段1，字段2) </span><br><span class="line">create unique index uni_index on user(phone,address);</span><br><span class="line"></span><br><span class="line"># 还有一种情况就是,我们需要为以前的表 创建这个索引,有可能以前的数据中存在重复的记录 那怎么办呢? </span><br><span class="line">alter ignore table tablename add unique index(aa,bb); </span><br><span class="line">#它会删除重复的记录（会保留一条），然后建立唯一索引，高效而且人性化。</span><br></pre></td></tr></table></figure>

<p>(2) 删除索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop index 索引名字 on 表名;</span><br></pre></td></tr></table></figure>

<h6 id="6-全文索引"><a href="#6-全文索引" class="headerlink" title="6.全文索引"></a>6.全文索引</h6><blockquote>
<p>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。</p>
<p> 全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。 </p>
<p> 在MySQL 5.6版本以前,只有MyISAM存储引擎支持全文引擎.在5.6版本中,InnoDB加入了对全文索引的支持,但是不支持中文全文索引.在5.7.6版本,MySQL内置了ngram全文解析器,用来支持亚洲语种的分词. </p>
</blockquote>
<p>（1）创建表的适合添加全文索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">    `title` char(255) CHARACTER NOT NULL ,</span><br><span class="line">    `content` text CHARACTER NULL ,</span><br><span class="line">    `time` int(10) NULL DEFAULT NULL ,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    FULLTEXT (content)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>（2）修改表结构添加全文索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE article ADD FULLTEXT index_content(content)</span><br></pre></td></tr></table></figure>

<p>（3）直接创建索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE FULLTEXT INDEX index_content ON article(content)</span><br></pre></td></tr></table></figure>

<p>（4）使用全文索引</p>
<p>​    跟普通索引稍有不同</p>
<p>   使用全文索引的格式：  MATCH (columnName) AGAINST (‘string’)</p>
<p>   eg:</p>
<p>​     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `student` WHERE MATCH(`name`) AGAINST(&apos;聪&apos;)</span><br></pre></td></tr></table></figure>

<p>​    当查询多列数据时：</p>
<p>​    建议在此多列数据上创建一个联合的全文索引，否则使用不了索引的。</p>
<p>​    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `student` WHERE MATCH(`name`,`address`) AGAINST(&apos;聪 广东&apos;)</span><br></pre></td></tr></table></figure>

<p>（5）使用全文索引需要注意的是：(基本单位是词)</p>
<ul>
<li><p>分词，全文索引以词为基础的，MySQL默认的分词是所有非字母和数字的特殊符号都是分词符(外国人嘛)</p>
</li>
<li><p>MySQL 中的全文索引，有两个变量，最小搜索长度和最大搜索长度，对于长度小于最小搜索长度和大于最大搜索长度的词语，都不会被索引。通俗点就是说，想对一个词语使用全文索引搜索，那么这个词语的长度必须在以上两个变量的区间内。</p>
<p>这两个的默认值可以使用以下命令查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &apos;%ft%&apos;;</span><br></pre></td></tr></table></figure>

<p>1<br>可以看到这两个变量在 MyISAM 和 InnoDB 两种存储引擎下的变量名和默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// MyISAM</span><br><span class="line">ft_min_word_len = 4;</span><br><span class="line">ft_max_word_len = 84;</span><br><span class="line"></span><br><span class="line">// InnoDB</span><br><span class="line">innodb_ft_min_token_size = 3;</span><br><span class="line">innodb_ft_max_token_size = 84;</span><br></pre></td></tr></table></figure>

<p>可以看到最小搜索长度 MyISAM 引擎下默认是 4，InnoDB 引擎下是 3，也即，MySQL 的全文索引只会对长度大于等于 4 或者 3 的词语建立索引，而刚刚搜索的只有 aaaa 的长度大于等于 4。</p>
<p>看下图：</p>
<img src="mysql索引类型及创建索引/全文索引相关变量.png" alt="全文索引配置图片" style="zoom:80%;">

<p>  ​    </p>
</li>
</ul>
<h4 id="四、缺点"><a href="#四、缺点" class="headerlink" title="四、缺点"></a>四、缺点</h4><ol>
<li><p>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行insert、update和delete。因为更新表时，不仅要保存数据，还要保存一下索引文件。</p>
</li>
<li><p>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会增长很快。</p>
</li>
</ol>
<h4 id="五、什么时候需要创建索引"><a href="#五、什么时候需要创建索引" class="headerlink" title="五、什么时候需要创建索引"></a>五、什么时候需要创建索引</h4><ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>查询中排序的字段创建索引将大大提高排序的速度（索引就是排序加快速查找）</li>
<li>查询中统计或者分组的字段；</li>
</ol>
<h4 id="六、什么时候不需要创建索引"><a href="#六、什么时候不需要创建索引" class="headerlink" title="六、什么时候不需要创建索引"></a>六、什么时候不需要创建索引</h4><ol>
<li>频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件</li>
<li>where条件里用不到的字段，不创建索引；</li>
<li>表记录太少，不需要创建索引；</li>
<li>经常增删改的表；</li>
<li>数据重复且分布平均的字段，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，因此他建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引。</li>
</ol>
<h4 id="七，注意事项-某些索引失效的情况"><a href="#七，注意事项-某些索引失效的情况" class="headerlink" title="七，注意事项(某些索引失效的情况)"></a>七，注意事项(某些索引失效的情况)</h4><blockquote>
<p>​        使用索引时，有以下一些技巧和注意事项：</p>
</blockquote>
<ol>
<li><strong>索引不会包含有null值的列</strong>。<br>只要列中包含有null值都将不会被包含在索引中，复合索引中只要有一列含有null值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为null。</li>
</ol>
<ol start="2">
<li><strong>使用短索引。</strong><br>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个char(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</li>
</ol>
<ol start="3">
<li><strong>索引列排序</strong>。<br>查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</li>
</ol>
<ol start="4">
<li><p><strong>like语句操作。</strong><br>一般情况下不推荐使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用索引</span><br><span class="line">select * from user where phone like&apos;1310001%&apos;</span><br><span class="line"></span><br><span class="line"># 将不会使用索引</span><br><span class="line">select * from user where phone like&apos;%310001%&apos;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p><strong>不要在列上进行运算</strong>。</p>
<blockquote>
<p>目前，MySQL没有支持函数索引。 这意味着如果在列上使用索引，表达式YEAR(column)也不会</p>
<p>利用索引。等于说是给字段进行运算会导致索引失效</p>
</blockquote>
</li>
</ol>
<p>   这将导致索引失效而进行全表扫描，例如</p>
<p>   SELECT * FROM table_name WHERE YEAR(column_name)&lt;2019;</p>
<p>   可以改成：</p>
<pre><code>SELECT * FROM table_name WHERE  column_name &lt; &apos;2019-01-01&apos;;</code></pre><ol start="6">
<li><strong>如果条件中有or，即使其中有条件带索引也不会使用索引 ， 要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</strong>。 </li>
</ol>
<ol start="7">
<li><p><strong>对于多列索引，不是使用的第一部分（最左前缀），则不会使用索引。 Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。</strong></p>
<p>例如索引是key index (a,b,c). 可以支持*<em>a| *</em>a,b| a,b,c,  3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</p>
</li>
</ol>
<ol start="8">
<li><strong>如果 mysql 估计使用全表扫描要比使用索引快,则不使用索引。</strong> </li>
</ol>
<ol start="9">
<li><strong>在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。</strong></li>
</ol>
<ol start="10">
<li><strong>如果排序的字段使用了索引，那么select的字段也要是索引字段，否则索引失效。特别的是如果排序的是主键索引则select * 也不会导致索引失效。</strong></li>
</ol>
<ol start="11">
<li><p><strong>强制类型转换会全表扫描，</strong></p>
<p>如果phone字段是varcher类型，则下面的SQL不能命中索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select  *  fromuser where phone=13800001234;</span><br></pre></td></tr></table></figure>

<p>这样就可以命中索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select  *  fromuser where phone=&apos;13800001234&apos;;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="八，查看sql语句执行时间和效率"><a href="#八，查看sql语句执行时间和效率" class="headerlink" title="八，查看sql语句执行时间和效率"></a>八，查看sql语句执行时间和效率</h4><h5 id="查看执行时间"><a href="#查看执行时间" class="headerlink" title="查看执行时间"></a>查看执行时间</h5><ol>
<li>show profiles; </li>
<li>show variables;查看profiling 是否是on状态； </li>
<li>如果是off，则 set profiling = 1； </li>
<li>执行自己的sql语句； </li>
<li>show profiles；就可以查到sql语句的执行时间；</li>
</ol>
<h5 id="查看操作了多少行"><a href="#查看操作了多少行" class="headerlink" title="查看操作了多少行"></a>查看操作了多少行</h5><p>在sql语句前面加上 explain就可以了；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from event;  </span><br><span class="line">+—-+————-+——-+——+—————+——+———+——+——+——-+  </span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |  </span><br><span class="line">+—-+————-+——-+——+—————+——+———+——+——+——-+  </span><br><span class="line">| 1 | SIMPLE | event | ALL | NULL | NULL | NULL | NULL | 13 | |  </span><br><span class="line">+—-+————-+——-+——+—————+——+———+——+——+——-+  </span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="各个属性的含义"><a href="#各个属性的含义" class="headerlink" title="各个属性的含义"></a>各个属性的含义</h5><p>各个属性的含义</p>
<p><strong>id</strong></p>
<ul>
<li>​    select查询的序列号， 这个不重要,查询序号即为sql语句执行的顺序 。</li>
</ul>
<p><strong>select_type</strong></p>
<ul>
<li>​    select查询的类型，主要是区别普通查询和联合查询、子查询之类的复杂查询。</li>
</ul>
<p><strong>table</strong></p>
<ul>
<li>​    输出的行所引用的表。</li>
</ul>
<p><strong>type</strong></p>
<ul>
<li>​    联合查询所使用的类型。</li>
</ul>
<ul>
<li>​    type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：</li>
</ul>
<ul>
<li><p>​    system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt;       index_subquery &gt; range &gt; index &gt; ALL</p>
<p>​    一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
</li>
</ul>
<p><strong>possible_keys</strong></p>
<ul>
<li>​    指出MySQL能使用哪个索引在该表中找到行。如果是空的，没有相关的索引。这时要提高性     能，可    通过检验WHERE子句，看是否引用某些字段，或者检查字段不是适合索引。</li>
</ul>
<p><strong>key</strong></p>
<ul>
<li>​    显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL。</li>
</ul>
<p><strong>key_len</strong></p>
<ul>
<li>​    显示MySQL决定使用的键长度。如果键是NULL，长度就是NULL。文档提示特别注意这个值可以得    出一个多重主键里mysql实际使用了哪一部分。</li>
</ul>
<p><strong>ref</strong></p>
<ul>
<li>​    显示哪个字段或常数与key一起被使用。</li>
</ul>
<p><strong>rows</strong></p>
<ul>
<li>​    这个数表示mysql要遍历多少数据才能找到，在innodb上是不准确的。</li>
</ul>
<p><strong>Extra</strong></p>
<ul>
<li>​    如果是Only index，这意味着信息只用索引树中的信息检索出的，这比扫描整个表要快。</li>
</ul>
<ul>
<li>​    如果是where used，就是使用上了where限制。</li>
</ul>
<ul>
<li>​    如果是impossible where 表示用不着where，一般就是没查出来啥。</li>
</ul>
<p>参考链接：</p>
<p>​        <a href="https://blog.csdn.net/u014518337/article/details/88179607" target="_blank" rel="noopener">https://blog.csdn.net/u014518337/article/details/88179607</a></p>
<p>​        <a href="https://www.jb51.net/article/158141.htm" target="_blank" rel="noopener">https://www.jb51.net/article/158141.htm</a> </p>
<p>​        <a href="https://blog.csdn.net/qq_33451004/article/details/68976090" target="_blank" rel="noopener">https://blog.csdn.net/qq_33451004/article/details/68976090</a></p>
<p>​         <a href="https://www.cnblogs.com/luohero/p/9139985.html" target="_blank" rel="noopener">https://www.cnblogs.com/luohero/p/9139985.html</a> </p>
<p>​         <a href="https://www.cnblogs.com/l199616j/p/11232392.html" target="_blank" rel="noopener">https://www.cnblogs.com/l199616j/p/11232392.html</a> </p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器函数</title>
    <url>/2017/11/11/%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<p>装饰器函数<br>装饰器：在函数运行时增加功能且不影响这个函数原有内容</p><a id="more"></a>
<p>普通装饰器函数<br>语法：</p>
<p>@func1<br>def func2():<br>    pass<br>@符号为装饰器函数语法，也常叫做语法糖</p>
<p>先来看一个简单的装饰器函数实现：</p>
<p>def wai(func):#装饰器函数，参数部分接收一个函数对象<br>    def nei():#闭包函数<br>        print(‘this is nei’) #要添加的功能<br>        return func()#返回接收到的函数func<br>    return nei #返回闭包函数</p>
<p>#在func2()执行的时候，会将func()也执行<br>@wai<br>def foo():<br>    print(‘this is foo’)<br>foo()<br>执行后的结果：</p>
<p>this is nei<br>this is foo<br>此时的foo函数在原有的基础上，额外多了装饰器函数中的定义的功能<br>被装饰函数foo在调用时，其实本质上是在进行 wai(foo)()</p>
<p>wai(foo)()过程解析：<br>装饰器函数wai接收被装饰函数foo作为参数<br>返回return nei，闭包函数nei被返回<br>nei()函数调用<br>由于nei函数的返回值为return func()，所以在内函数调用结束时，被装饰函数也会被调用<br>被装饰函数在调用时，被调用的函数有三个： wai() nei() 以及被装饰函数func()</p>
<p>接下来，让我们充满动力的继续看这样一个例子</p>
<p>被装饰的函数带有参数<br>我们考虑到，之前的普通装饰器并不能解决；被装饰函数带有参数的问题，如果有这样一个函数</p>
<p>def foo(a,b):<br>    print(a+b)<br>这个函数在定义时，明确两个参数，并且做相加打印的操作<br>我们有一个胆大的想法，在这个两值相加函数运行后的结果，分别给 a和 b两值多100，但是不修改这个原有 foo函数</p>
<p>def wai(func):#装饰器函数<br>    def nei(a,b): #内部闭包函数，在这里的a,b其实也就是我们被装饰函数传入的参数a,b<br>        a = a + 100 #在这里，为两个参数分别+100<br>        b = b + 100<br>        #我们还可以在装饰器函数中修改传递函数中变量的值<br>        return func(a,b)<br>    return nei<br>@wai<br>def foo(a,b):<br>    print(a+b)<br>foo(3,5)<br>按照惯有思维，3+5的结果应该是8，但是由于该函数被装饰，我们来看下结果吧：</p>
<p>30<br>执行后的结果，并不是本身的3+5<br>装饰器函数内部的闭包函数参数部分接收到了被装饰函数传入的参数，并且在其内部进行了值的修改<br>最后在闭包函数的返回值处，将修改后的函数传入到return func(a,b)，此时被装饰函数调用，但是传入的参数已经不再是之前的3和5了</p>
<p>装饰器函数带有参数<br>最后，让我们看一下装饰器函数的终极套路<br>如果我们装饰器函数需要参数怎么办？<br>你会发现，此时wai函数和nei函数的参数部分都有了自己的意义，那么这个装饰器函数的参数该怎么接收？</p>
<p>def arg_func(choice=’Man’): #我们额外包装一层函数用来接收装饰器函数的参数<br>    def wai(func): #装饰器函数<br>        def nei(name): #闭包函数<br>            print(‘你好:’,name)<br>            if choice == ‘Man’: #如果装饰器函数接收到的参数值为Man<br>                print(‘去工作’)<br>            if choice == ‘Woman’:<br>                print(‘去逛街’)<br>            return func(name) #闭包函数返回被装饰函数调用<br>        return nei #装饰器函数返回内部闭包函数<br>    return wai #最外层函数返回装饰器函数<br>choice = input(‘请输入你的性别:’)<br>name = input(‘请输入你的名字:’)<br>@arg_func(choice)<br>def func(name):<br>    print(“你的名字是:”,name)<br>func(name)<br>执行的效果</p>
<p>请输入你的性别:Man<br>请输入你的名字:张三<br>你好: 张三<br>去工作<br>你的名字是: 张三<br>请输入你的性别:Woman<br>请输入你的名字:李四<br>你好: 李四<br>去逛街<br>你的名字是: 李四<br>总结<br>实现装饰器</p>
<p>定义闭包函数<br>闭包函数返回装饰器函数接收参数调用<br>装饰器函数参数部分接收被装饰函数对象<br>闭包函数参数部分接收被装饰函数参数部分<br>如果需要装饰器函数带参数，在最外层在包裹一层函数，形参部分接收装饰器函数参数，返回装饰器函数即可</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2017/10/11/%E6%AD%A3%E5%88%99/</url>
    <content><![CDATA[<p>正则<br>一些特殊符号及文本组合在一起的用来描述字符或字符串的一些规则，叫做正则</p><a id="more"></a>
<p>正则中的特殊符号<br>匹配一个范围： []<br>[A-Z]：A, B, C…<br>[0-9]：1, 2, 3…</p>
<p>匹配任何数字字符：\d<br>\d：1, 2, 3…</p>
<p>匹配任何空白符：\s<br>\s：\t (水平制表), \v (垂直制表), \n (换行), \r (回车), \f (换页)</p>
<p>匹配任何数字、字母、字符及下划线：\w<br>\w： a, 1, _</p>
<p>匹配除了换行符任意一个单个字符：.<br>a.c：abc, a2c, a_c<br>..：匹配任意字符组成的两个长度的字符串</p>
<p>匹配前面出现的正则表达式0次或多次：<strong>*<br>a<em>：aaa 或是一个空<br>[abc]</em></strong>：aaabbb abc bbaacc</p>
<p>匹配前面出现的正则表达式0次或一次：?<br>a?：a 或是一个空</p>
<p>匹配前面出现的正则表达式1次或多次：+<br>a+：aaa a<br>abc+：abcabc</p>
<p>匹配前面出现的正则表达式固定次数：{}<br>a{5}： aaaaa<br>\d{5}：12345, 22222</p>
<p>匹配明确的多个选择：|<br>a | b：a, b<br>abc|cdf|123：abc, cdf, 123</p>
<p>匹配字符串的开头或结尾：^, $<br>^abc：匹配所有以abc开头的字符串<br>abc$：匹配所有以abc结尾的字符串</p>
<p>否定匹配：[^]<br>[^a]：匹配除了a之外的所有字符</p>
<p>re模块函数<br>re.compile(pattern)<br>编译正则表达式<br>一般的，特殊字符再进行正则匹配的时候，如果你不预先编译正则表达式，解释器也会在你传入参数的时候进行编译<br>一些常用正则表达式，我们可以提前使用该函数进行预先编译，提高程序的效率</p>
<blockquote>
<blockquote>
<blockquote>
<p>import re<br>regex = re.compile(‘abc’)<br>re.match(pattern,string)<br>尝试使用正则模式pattern在字符串中的开头进行严格匹配，如果开头匹配失败则匹配失败<br>匹配成功：返回一个匹配对象，匹配到的值可通过group函数获取<br>匹配失败：返回None</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>res = re.match(‘abc’,’abcac’)<br>&lt;_sre.SRE_Match object; span=(0, 3), match=’abc’&gt; #返回表示选择的区间以及匹配到的结果</p>
<blockquote>
<blockquote>
<blockquote>
<p>res.group()<br>‘abc’<br>re.findall(pattern,string)<br>返回字符串中正则模式的所有非重复出现</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>re.findall(‘*‘,’a<em>b</em>c<em>‘)<br>[‘</em>‘, ‘<em>‘, ‘</em>‘]<br>注意：由于匹配的表达式中，我希望匹配的只是单纯的*****号，并不具有特殊意义，所以要加一个斜杠防止转义</p>
</blockquote>
</blockquote>
</blockquote>
<p>re.search(pattern,string)<br>返回字符串中正则模式的第一次出现，没有匹配结果则返回None<br>结果可以通过返回值的group函数获取</p>
<blockquote>
<blockquote>
<blockquote>
<p>res = re.search(‘*‘,’a<em>b</em>c<em>‘)<br>&lt;_sre.SRE_Match object; span=(1, 2), match=’</em>‘&gt;<br>res.group()<br>‘*’<br>re.sub(str1,str2,str3)<br>re.subn(str1,str2,str3)<br>str1：要替换的字符串<br>str2：替换成什么<br>str3：在哪个字符串里进行替换</p>
</blockquote>
</blockquote>
</blockquote>
<p>这两个函数都可以实现搜索和替换功能，均返回一个替换之后的新字符串<br>subn函数会以元组形式包含一个表示替换的总数</p>
<blockquote>
<blockquote>
<blockquote>
<p>var = re.sub(‘*‘,’<em>‘,’a<em>b</em>c*’)<br>var<br>‘a_b_c</em>‘<br>var = re.subn(‘*‘,’<em>‘,’a<em>b</em>c*’)<br>var<br>(‘a_b_c</em>‘, 3)<br>贪婪非贪婪<br>如果问号?紧跟在任何使用闭合（类似* + 这样的操作符）的匹配后面， 它将直接要求正则表达式引擎匹配尽可能少的次数，这叫做非贪婪</p>
</blockquote>
</blockquote>
</blockquote>
<p>贪婪匹配：正则表达式引擎将试图“吸收”匹配该模式的尽可能多的字符<br>非贪婪匹配：问号要求正则表达式引擎去“偷懒”，如果可能，就在当前的正则表达式中尽可能少地匹配字符，留下尽可能多的字符给后面的模式</p>
<blockquote>
<blockquote>
<blockquote>
<p>import re<br>mystr = ‘a<em>b</em>c<em>d</em>e<em>f</em>g’ac<br>re.findall(‘.+?’, mystr) #非贪婪模式进行匹配<br>[‘a’, ‘<em>‘, ‘b’, ‘</em>‘, ‘c’, ‘<em>‘, ‘d’, ‘</em>‘, ‘e’, ‘<em>‘, ‘f’, ‘</em>‘, ‘g’]<br>re.findall(‘.+’, mystr) #贪婪模式进行匹配<br>[‘a<em>b</em>c<em>d</em>e<em>f</em>g’]<br>re.findall(‘.<em>‘, mystr) #贪婪模式进行匹配<br>[‘a<em>b</em>c<em>d</em>e<em>f</em>g’, ‘’]<br>re.findall(‘.</em>?’, mystr) #非贪婪模式进行匹配<br>[‘’, ‘’, ‘’, ‘’, ‘’, ‘’, ‘’, ‘’, ‘’, ‘’, ‘’, ‘’, ‘’, ‘’] #结果不同在于对+号和*号特殊字符的解释</p>
</blockquote>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库索引</title>
    <url>/2017/10/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>引言<br>说白了,数据库的索引问题就是查找问题</p><p>数据库索引,是数据库管理系统中一个排序的数据结构,以协助快速查询,更新数据库中表的数据.索引的实现通常使用B树和变种的B+树(mysql常用的索引就是B+树)</p><a id="more"></a>

<p>除了数据之外,数据库系统还维护为满足特定查找算法的数据结构,这些数据结构以某种方式引用数据.这种数据结构就是索引</p>
<p>创建索引的好处<br>①通过创建索引,可以在查询的过程中,提高系统的性能</p>
<p>②通过创建唯一性索引,可以保证数据库表中每一行数据的唯一性</p>
<p>③在使用分组和排序子句进行数据检索时,可以减少查询中分组和排序的时间</p>
<p>创建索引的坏处<br>①创建索引和维护索引要耗费时间,而且时间随着数据量的增加而增大</p>
<p>②索引需要占用物理空间,如果要建立聚簇索引,所需要的空间会更大</p>
<p>③在对表中的数据进行增加删除和修改时需要耗费较多的时间,因为索引也要动态地维护</p>
<p>应该在哪些列上创建索引呢<br>①经常需要搜索的列上</p>
<p>②作为主键的列上</p>
<p>③经常用在连接的列上,这些列主要是一些外键,可以加快连接的速度</p>
<p>④经常需要根据范围进行搜索的列上</p>
<p>⑤经常需要排序的列上</p>
<p>⑥经常使用在where子句上面的列上</p>
<p>不应该在哪些列上创建索引<br>①查询中很少用到的列</p>
<p>②对于那些具有很少数据值的列.比如人事表的性别列,bit数据类型的列</p>
<p>③对于那些定义为text,image的列.因为这些列的数据量相当大</p>
<p>④当对修改性能的要求远远大于搜索性能时.因为当增加索引时,会提高搜索性能,但是会降低修改性能</p>
<p>索引的分类和使用<br>按物理存储角度分：</p>
<p>聚集索引</p>
<p>表记录的排列顺序和索引的排列顺序一致,所以查询效率快,只要找到第一个索引值记录,其余连续性的记录在物理上一样连续存放.聚集索引的缺点就是修改慢,因为为了使表记录和索引的排列顺序一致,在插入记录的时候,会对数据页重新排序</p>
<p>非聚集索引</p>
<p>表记录和索引的排列顺序不一定一致,两种索引都采用B+树的结构,非聚集索引的叶子层并不和实际数据页相重叠,而采用叶子层包含一个指向表记录的指针.非聚集索引层次多,不会造成数据重排</p>
<p>按逻辑角度分</p>
<p>2）普通索引，最基本的索引，它没有任何的限制</p>
<p>4）复合索引（又叫做多列索引，联合索引）：多个字段上建立的索引，提高复合条件查询的速度</p>
<p>创建联合索引：create index idx_name_age on student(name,age);</p>
<p>查看索引：show index from student;</p>
<p>数据库索引在什么情况下失效<br>（1）条件中用or（这就是为什么少用or的原因）</p>
<p>（2）</p>
<p>对于多列（复合、联合）索引，不是使用的第一部分，则不会使用索引。(最左匹配原则或者叫做最左前缀原则）</p>
<p>比如：Index_SoftWareDetail索引包含（a，b，c） 三列，但是查询条件里面，没有a，b 列，只有c 列，那么 Index_SoftWareDetail索引也不起作用。</p>
<p>例如：bc   c   acb bac 都是不行的</p>
<p>（3）like的模糊查询以%开头，索引失效</p>
<p>（4）如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不会使用索引</p>
<p>（5）如果MySQL预计使用全表扫描要比使用索引快，则不使用索引</p>
<p>（6）判断索引列是否不等于某个值时。‘!=’操作符。比如：select * from SoftWareDetailInfo where SoftUseLine != 0</p>
<p>（7）</p>
<p>对索引列进行运算。这里运算包括+-*/等运算。也包括使用函数。比如：</p>
<p>select * from SoftWareDetailInfo where SoftUseLine +0= 0</p>
<p>此时索引不起作用。</p>
<p>select * from SoftWareDetailInfo where count(SoftUseLine) = 0</p>
<p>此时索引也不起作用。</p>
<p>也就是说如果不是直接判断索引字段列，而是判断运算或其它函数处理后的索引列索引均不起作用。</p>
<p>（8）索引字段进行判空查询时。也就是对索引字段判断是否为NULL时。语句为is null 或is not null。</p>
<p>　　比如：select * from SoftWareDetailInfo where CreateTime is null 此时就不检索time字段上的索引表了。也就是索引在这条语句执行时失效了。</p>
<p>　　接着再执行</p>
<p>select * from SoftWareDetailInfo where CreateTime = ‘2015-04-11 00:00:00’ 此时就会检索索引表了。索引又起作用了。</p>
<p>（9）范围列可以用到索引（联合索引必须是最左前缀），但是范围列后面的列无法用到索引</p>
<p>索引的优化<br>①尽量不要使用左模糊和全模糊，如果需要可以使用搜索引擎来解决</p>
<p>②union,in和or都可以命中索引，建议使用in</p>
<p>③负向条件查询不能使用索引，可以优化为in查询</p>
<p>负向条件查询有：!=  &lt;&gt;  not in  not like等等</p>
<p>例如：select * from user where status!=1 and status!=2</p>
<p>优化为：select * from user where status in (0,3,4);</p>
<p>④合理使用联合索引的最左前缀原则</p>
<p>如果在(a,b,c)三个字段上建立联合索引，那么它能够加快 a | (a,b) | (a,b,c) 三组查询速度。</p>
<p>比如说把(username,password)建立了联合索引，因为业务上几乎没有password的单条件查询，而有很多username的单条件查询需求，所以应该建立(username,password)的联合索引，而不要建立(password,username)的联合索引</p>
<p>注意：（1）建立联合索引的时候，要把查询频率较高的列放在最左边</p>
<p>（2）如果建立了(a,b)索引，就不必再独立建立a索引。同理如果建立了(a,b,c)联合索引，就不必再独立建立a,(a,b)索引</p>
<p>（3）存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如     where a&gt;? and b=?，那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。</p>
<p>（4）最左前缀原则，并不是要求where后的顺序和联合索引的一致。下面的 SQL 语句也可以命中 (login_name, passwd) 这个联合索引。</p>
<p>selectuid, login_time from user where passwd=? andlogin_name=?<br>但还是建议 where 后的顺序和联合索引一致，养成好习惯。</p>
<p>⑤把计算放到业务层而不是数据库层。（因为对索引列进行运算，不能命中索引）</p>
<p>⑥表数据比较少、更新十分频繁、数据区分度不高的字段上不宜建立索引。</p>
<p>一般区分度在80%以上的时候就可以建立索引，区分度可以使用 count(distinct(列名))/count(*) 来计算。</p>
<p>⑦强制类型转换会全表扫描</p>
<p>例如：如果phone字段是varchar类型，则下面的sql不能命中索引</p>
<p>select * from user where phone = 18838003017</p>
<p>可以优化为：select * from user where phone = ‘18838003017’</p>
<p>⑧利用覆盖索引进行查询操作，避免回表</p>
<p>select uid,login_time from user where username=? and password=?</p>
<p>如果建立了(username,password,login_time)的联合索引,由于login_time已经建立在索引中了,被查询的username和password就不用去row上获取数据了,从而加速查询</p>
<p>⑨在order by和group by中要注意索引的有序性</p>
<p>如果order by是组合索引的一部分,应该将该字段放在组合索引的最后</p>
<p>例如:where a=? and b=? order by c -&gt;可以建立联合索引(a,b,c)</p>
<p>如果索引中有范围查找,则索引的有序性无法利用</p>
<p>例如:where a&gt;10 order by b -&gt;索引(a,b)无法排序</p>
<p>⑩建立索引的列,不许为null</p>
<p>单列索引不存 null 值，复合索引不存全为 null 的值，如果列允许为 null，可能会得到“不符合预期”的结果集，所以，请使用 not null 约束以及默认值。</p>
<p>sql语句的优化<br>①能用到索引尽量用到索引.对索引的优化实际上就是sql语句的调优</p>
<p>②任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>
<p>③尽量使用where,而不要使用having</p>
<p>④尽量使用多表查询,不要使用子查询</p>
<p>⑤where后的and.or左右执行顺序是从右至左</p>
<p>运算符为and时–尽量把为假的放在右边</p>
<p>运算符为or时–尽量把为真的放在右边</p>
]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
</search>
